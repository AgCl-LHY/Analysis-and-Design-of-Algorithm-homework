#include<stdio.h>
#include<stdlib.h>
#include<memory.h>
#include<string.h>
#include<algorithm>

using namespace std;

const int INF = 0x3f3f3f3f;
const int N = 1005;
//创建存边的结构体
struct node { 
	int x, y, z;
}edge[N];

int fa[N], n, m, ans;

//重载运算符，方便排序
bool operator <(node a, node b) {
	return a.z < b.z;
}

//并查集操作函数
void init(){
	for (int i = 0; i < N; i++)
		fa[i] = i;
}
int find(int x){
	return fa[x] == x ? x : fa[x] = find(fa[x]);
}

int main(void)
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; i++) {
		scanf("%d%d%d", &edge[i].x, &edge[i].y, &edge[i].z);
	}
	sort(edge + 1, edge + m + 1);//按边权排序
	init();//初始化并查集
	printf("加入顺序:\n");
	//求最小生成树
	for (int i = 1; i <= m; i++) {
		int x = find(edge[i].x);
		int y = find(edge[i].y);
		if (x == y) continue;//如果x点和y点已经连通（被选进生成森林里了）
		fa[x]=y;//合并
		printf("v%d v%d\n", edge[i].x, edge[i].y);
		ans += edge[i].z;
	}
	printf("最小生成树边权和为:\n%d\n", ans);
}
/*测试例子
6 10
1 2 6
1 3 1
1 4 5
2 3 5
2 5 3
3 4 5
3 5 6
3 6 4
4 6 2
5 6 6
*/
